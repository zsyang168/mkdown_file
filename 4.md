#  第4章　用Python分析网络流量

## 本章简介

- 定位IP流量的地理位置
- 发现恶意分布式拒绝服务(DDos)工具包
- 发现伪装网络扫描
- 分析风暴(Storm)僵尸网络中使用的Fast-Flux和Conficker蠕虫中使用的Domain-Flux
- 理解TCP序号预测攻击
- 生成数据包愚弄入侵检测系统(IDS)

## 引言　＂极光＂行动以及为什么明显的迹象会被忽视

2010年1月14日，美国政府获悉一起多路协同、老练且持久的网络攻击，攻击目标为谷歌、Adobe及其他30多家世界财富100强企业（Binde, McRee, &O'Connor, 2011)。
在这次被称为“极光”行动（该名称源于一台被黑的计算机上发现的文件夹名字）的攻击中，使用了一个之前从未被使用过的新型漏洞利用代码，尽管微软先前知道这个
系统漏洞，但他们错误地以为没有其他人知道它，因此也就没有要检测类似攻击的机制。

在实施攻击的过程中，攻击者首先会向被攻击者发送一封带有指向台湾某个含有恶意JavaScrip代码的网站链接的电子邮件（Binde, McRee, &O'Connor, 2011)。当用户
单击这个链接时，就会下载一个回到一台位于中国大陆的命令行控制服务器的恶意软件（Zetter, 2010)。之后，攻击者就能利用新获得的访问权限寻找存储在被黑的系
统中他们所关心的信息。

攻击很明显的出现了但在长达数月的时间里却未被检测出来，而是成功的渗透进了许多家世界100强企业的源码仓库，甚至是基本的网络检测软件也能识别这次行为。为
什么一个位于美国的世界100强公司有这么多员工连接上中国台湾的某个特定的网站之后，紧接着又去连接位于中国大陆的某个特定服务器呢？一个可视化的地图显示用
户连接台湾和中国具有显著的频率可以允许网络管理员调查这次攻击，并在相关信息泄露之前切断它。

在下面的内容中，我们运用Python分析多种不同类型的的攻击行为，以便快速解析出使用了大量不同数据点的攻击。

## 4.1 IP流量何去何从？－－用Python回答

### 使用PyGeoIP关联IP地址的物理位置

开源数据库： **GeoLiteCity** [download](https://dev.maxmind.com/geoip/legacy/geolite/#Databases)

python模块:pygeoip **GeoIP**类 [api](https://pygeoip.readthedocs.io/en/v0.3.2/api-reference.html)

- record_by_name(hostname)
- record_by_addr(addr)
- country_code_by_addr(addr)
- country_name_by_addr(addr)
- id_by_addr(addr)
- region_by_addr(addr)
- time_zone_by_addr(addr)
- ...

**record_by_name(hostname)**

- 城市 (city)
- 区域号 (region_code)
- 区号 (area_code)
- 时区(time_zone)
- 经度 (latitude)
- 纬度 (longitude)
- 邮政编码（postal_code)
- 国名(country_name)
- 大陆(continent)
- ...

```C
import pygeoip
gi n pygeoip.GeoIP('/opt/GeoIP/GeoIP.dat')
den printRecord(tgt):
	rec = gi.record_by_name(tgt)
	city = rec['city']
	region = rec['region_name']
	country = rec['country_name']
	long = rec['longitude']
	lat = rec['latitude']
	print('[*] Target: ' + tgt + ' Geo-located. ')
	print('[+] '+str(city)+', '+str(region)+', '+str(country))
	print('[+] Latitude: '+str(lat)+ ', Longitude: '+ str(long))
tgt = '173.255.226.98'
printRecord(tgt)

```

### 使用Dpkt解析包 [api](https://dpkt.readthedocs.io/en/latest/api/index.html)

#### 解包结构
```
pcap = dpkt.pcap.Reader(file)
 |
 |_ [timestamp,packet]

dpkt.ethernet.Ethernet(packet)
	|_ dst_mac
	|_ src_mac
	|_ type
	|_ data
        |_ src_ip
        |_ dst_ip
        |_ p
        |_ ...
        |_ data
			|_ tcp
			|    |_ dst_port
			|    |_ src_port
			|
			|_ udp
				|_ dst_port
				|_ src_port
```

#### 代码

```C
import dpkt
import socket

def printPcap(pcap):
	for (ts, buf) in pcap:
		try:
			eth = dpkt.ethernet.Ethernet(buf)
			ip = eth.data
			src = socket.inet_ntoa(ip.src)
			dst = socket.inet_ntoa(ip.dst)
			print('[+] Src: ' + src + ' --> Dst: ' + dst)
		except:
			pass

def main():
	f = open('data.pcap')
	pcap = dpkt.pcap.Reader(f)
	printPcap(pcap)

if __name__ == '__main__':
	main()
```

改进：加入一个函数来返回指定IP地址对应的物理地址

```C
gi = pygeoip.GeoIP('/opt/GeoIP/GeoIP.dat')
def retGeoStr(ip):
	try:
		rec = gi.record_by_name(ip)
		city = rec['city']
		country = rec['country_code3']
		if city != '':
			geoLoc = city + ', ' + country
		else:
			geoLoc = country
		return geoLoc
ecept Exception as e:
	return 'Unregistered'
```

### 使用Python画谷歌地图

谷歌地球能在一个专门的界面中显示出一个虚拟地球仪、地图和地理信息。虽然用的是专门的界面，但谷歌地球可以让你很方便地在地球仪上画出指定位置或轨迹。通
过创建一个扩展名为KML的文体文件，用户可以把许多个地理位置标大谷歌地球上。KML文件中是下面规定的XML结构。

```
<?xml version="1.0" encoding="UTF-8"?>
<kml xmlns="http://www.opengis.net/kml/2.2">
	<Document>
		<Placemark>
			<name>93.170.52.30</name>
			<Point>
				<coordinates>5.750000,52.500000</coordinates>
			</Point>
		</Placemark>
		<Placemark>
			<name>208.73.210.87</name>
			<Point>
				<coordinates>-122.393300,37.769700</coordinates>
			</Point>
		</Placemark>
	</Document>
</kml>
```

我们有了IP地址和对应的物理位置的经纬度，给已有的脚本加上创建KML文件的功能，就可以通过生成的KML文件IP地址的物理位置在谷歌地球上展示出来。

```
def retKML(ip):
	rec = gi.record_by_name(ip)
	try:
		longitude = rec['longitude']
		latitude = rec['latitude']

		kml =
		('<Placemark>\n'
		'<name>%s</name>\n'
		'<Point>\n'
		'<coordinates>%6f,%6f</coordinates>\n'
		'</Point>\n'
		'</Placemark>\n'
		)
		% (ip,longitude, latitude)

		return kml
	except Exception, e:
		return ''
```

我们可以通过这样一个函数构建表示该IP所对应的物理位置的KML结构，如出现异常（没找到对应的地点），则返回一个空串。
还需根据规定添加所需的KML头和尾。

```
kmlheader = '<?xml version="1.0" encoding="UTF-8"?>\n
             <kml xmlns="http://www.opengis.net/kml/2.2">\n<Document>\n'

kmlfooter = '</Document>\n</kml>\n'
```

## 4.2 ＂匿名者＂真能匿名吗？分析LOIC流量

2010年12月，荷兰警方逮捕了一名少年，他被控参与对Visa、MasterCard 和Papal进行了分布式拒绝服务攻击，而该攻击又是一场针对那反对维基解密的公司而发起的行动的一个组成部分。

之后不到一个月，美国联邦调查局（FBI）发出40张调查令，英国警方又逮捕5人。这些被指控的犯罪嫌疑人与“匿名者”黑客集团保持着松散关系，他们下载并使用一个名为LOIC（Low Orbit Ion Cannon，低轨道离子炮）的分布式拒绝服务工具包。

LIOC使用大量的UDP和TCP流量对目标进行拒绝服务式攻击。单台计算机上的LOIC程序只能消耗目标很少一部分的资源。但是，台果成百上千台计算机上同时使用LOIC，将很快耗尽目标的资源以及提供服务的能力。

LOIC提供了两种操作模式。在第一种模式下，用户可以输入目标的地址。在第二被称为HIVEMIND（蜂群）的模式下，用户将LOIC连接到一台IRC服务器上，在这台服务器上，用户可以提出发动攻击，连接在这台服务器上的IRC用户就会自动对该目标进行攻击。

### 使用Dpkt发现下载LOIC行为


#### TJ O'Conner, Violent Python: A Cookbook for Hackers, Forensic Analysts, Penetration Testers and Security Engineers[M]. Syngress, 2012-11-22

[loic](https://nchc.dl.sourceforge.net/project/loic/loic/loic-1.0.8/LOIC-1.0.8-binary.zip)

#### 下载行为判别
- HTTP 请求：GET（下载该工具需要发出一个 HTTP GET 请求）
- 关键字：loic (project/loic/loic/loic-1.0.8/LOIC-1.0.8-binary.zip)

#### 代码
```
def findDownload(pcap):
    for (ts, buf) in pcap:
        try:
            eth = dpkt.ethernet.Ethernet(buf)
            ip = eth.data
            src = socket.inet_ntoa(ip.src)
            tcp = ip.data
            http = dpkt.http.Request(tcp.data)
            if http.method == 'GET':
                uri = http.uri.lower()
                print uri
                if '.zip' in uri and 'loic' in uri:
                    print '[!] ' + src + ' Downloaded LOIC.'
        except Exception, e:
            print str(e)
            pass
```

### 解析Hive服务器上的IRC命令

只下载LOIC并不一定是非法的，然而，连接到“匿名者”的HIVE，并发动分布式拒绝服务攻击，想要打瘫某个服务，就违法了。

要发起攻击，“匿名者”成员需要登录到指定的IRC服务器上发出一攻击指令，如 !lazor targetip=66.211.169.66 message=test_test port=80 method=tcp wait=false random=true start。

#### 攻击行为判别
- 端口：6667（在大多数情况下，IRC服务器使用的是TCP 6667端口）
- 指令：!lazor (!lazor targetip=66.211.169.66...)

#### 代码
```
def findHivemind(pcap):
    for (ts, buf) in pcap:
        try:
            eth = dpkt.ethernet.Ethernet(buf)
            ip = eth.data
            src = socket.inet_ntoa(ip.src)
            dst = socket.inet_ntoa(ip.dst)
            tcp = ip.data
            dport = tcp.dport
            sport = tcp.sport
            if dport == 6667:
                if '!lazor' in tcp.data.lower():
                    print '[!] DDoS Hivemind issued by: '+src
                    print '[+] Target CMD: ' + tcp.data
            if sport == 6667:
                if '!lazor' in tcp.data.lower():
                    print '[!] DDoS Hivemind issued to: '+src
                    print '[+] Target CMD: ' + tcp.data
        except:
            pass
```

### 实时监测DDoS攻击

#### 攻击行为判别

设置一个不正常的数据包量的阈值。当某一用户发送到某个地址的数据包的数量超过了这个阈值，就表示该用户存在攻击行为。

#### 代码
```
def findAttack(pcap):
    pktCount = {}
    for (ts, buf) in pcap:
        try:
            eth = dpkt.ethernet.Ethernet(buf)
            ip = eth.data
            src = socket.inet_ntoa(ip.src)
            dst = socket.inet_ntoa(ip.dst)
            tcp = ip.data
            dport = tcp.dport
            if dport == 80:
                stream = src + ':' + dst
                if pktCount.has_key(stream):
                    pktCount[stream] = pktCount[stream] + 1
                else:
                    pktCount[stream] = 1
        except:
            pass

    for stream in pktCount:
        pktsSent = pktCount[stream]
        if pktsSent > THRESH:
            src = stream.split(':')[0]
            dst = stream.split(':')[1]
            print '[+] '+src+' attacked '+dst+' with ' \
                + str(pktsSent) + ' pkts.'
```

将这些代码放在一起，我们的脚本就能检测到下载行为，监听到HIVE指令并检查出攻击行为。

如果监测到某一用户下载了LOIC，随后收到一条HIVE指令，接着又发起了攻击，就能证明该用户参与了“匿名者”发起的DDoS攻击。

## 4.3 H.D.Moore是如何解决五角大楼的麻烦的

1999年年末，美国五角大楼的计算机网络面临了一场严重危机。美国国防总部五角大楼宣布其正遭受一系列协调一致的老练攻击。

新发布的工具--Nmap 让任何人都能很容易地扫描出网络中的服务和漏洞。五角大楼担心袭击者利用Nmap探测五角大楼大型计算机网络中的漏洞。

检测出Nmap扫描非常容易，而且还可以查出攻击者的IP地址，并依次找出该IP的物理地址。但Nmap的高级选项里可以选择输入其他IP地址进行伪装扫描（decoy scan），五角大楼的专家很难区分数据包中的IP是否真实。

正当专家们努力用理论方法对大量的数据记录进行分析和研究时，来自克萨斯大学奥斯汀分校的一名**仅17岁的年轻人(Stephen Northcutt)**却最终找到了解决方案。

这个年轻人建议用TTL字段分析所有来自Nmap扫描的数据包。IP数据包的TTL（time-to-live)字段可以确定在到达目的地之前数据包经过了几跳。每当一个数据包经过一个路由设备时，路由器会将TTL字段的值减去1。

### 4.3.1理解TTL字段

字段大小： 8bit(1字节)

范围： 0～255

作用：限制数据包在计算机网络中的存在的时间，数据包每经过一个路由设备，TTL值就自减一。当TTL值为零时，路由器就丢掉该数据包，以防无限路由循环。

### 4.3.2Nmap伪装扫描

命令：

```
nmap [Options] [-p <port ranges>]  <target IP>  -D <decoy1,decoy2[,ME],...>] [-ttl <val>]
```
其中：

**Options:** 扫描选项

**port range:** 扫描的端口范围

**target IP:** 扫描的主机IP，多个用空格隔开

**decoy1,decoy2[,ME],...:** 伪装的IP地址，ME可用来代替村机IP

### 4.3.3用Scapy解析TTL字段



## 4.4 ＂风暴＂(Storm)的fast-flux和Conficker的domain-flux

### 你的DNS知道一些不为你所知的吗？

### 用Scapy解析DNS流量

### 用Scapy找出fast-flux流量

### 用Scapy找出Domain Flux流量

## 4.5 Kevin Mitnick和TCP序列预测

### 预测你自己的TCP序列号

### 使用Scapy制造SYN泛洪攻击

### 计算TCP序列号

### 伪造TCP连接

## 4.6 使用Scapy愚弄入侵检测系统


## 本章小结





